# [내일배움캠프 사전캠프] C++ 언어의 기초적인 요소


## 언리얼에서 사용하는 C++ 언어의 기초적인 요소

- 변수 선언 방법
- 자료형
- 연산자
- 제어문
- 반복문
- 함수
- 포인터
- 클래스
- 상속
- 템플릿


## 변수 선언

**변수 선언**이란. 프로그램에서 사용할 **데이터를 저장할 공간을 확보**하는 과정이다.

변수 선언 시 **자료형과 변수 이름**을 지정하여 **저장할 데이터**와 **변수의 고유한 이름**을 설정해야 한다.

### 변수 선언 예시

```cpp
int num; // 자료형 변수 이름
```

위 코드는 `int` 자료형의 변수 `num`을 선언한 것이다. `num`은 **정숫값을 저장할 수 있는 공간**이 되었다.

또한 변수 선언 시 **초깃값을 지정**할 수 있으며 

초깃값을 지정한 변수는 **선언과 동시에 해당 값으로 초기화** 된다.

```
int num = 12; 
```

### 변수 선언 시 주의 사항

1. **변수 이름 규칙**:
  - 변수 이름은 **알파벳, 숫자, 언더바(_)**로만 구성해야 한다.
  - 변수 이름은 **숫자로 시작**할 수 없고, **특수문자**는 사용할 수 없다.
  - 변수 이름에 **공백**을 포함할 수 없다.
2. **대소문자 구분**:
  - C++에서는 **대소문자를 구분**하므로, `num`과 `Num`은 **서로 다른 변수**로 취급한다.

## 자료형 

C++에서는 다양한 자료형이 있다. 

자료형에 따라 컴파일러는 변수에 할당할 **메모리 크기와 데이터 해석 방식**을 결정하고,

프로그램의 **메모리 사용을 최적화하고 성능을 향상**시켜 

**데이터 처리를 효율적으로 저리** 할 수 있다.

### 정수형 

정수형은 **정숫값을 저장**하며, 정수형에 속한 자료형에 따라 **처리할 수 있는 값의 범위**가 다르기에 

적절한 자료형을 사용하면 **메모리 사용을 최적화**할 수 있다.

- **int** : 32비트 정수, 범위는 -2,147,483,648 ~ 2,147,483,647이다.

- **char** : 8비트 정수, -128~127 사이의 값을 저장한다. 문자를 저장할 때도 사용되며, ASCII 코드를 통해 숫자로 변환해 처리된.

- **short** : 16비트 정수, 작은 정숫값을 저장할 때 사용합니다.

- **long long** : 64비트 정수, 더 큰 숫자를 처리하는 데 유용합니다.

### 실수형

실수형은 **소수점을 포함하는 실숫값을 저장**하는 데 사용합니다. 

3.14, -12.3, 0.10 같은 값을 저장할 수 있습니다.

- **float** : 32비트 실수로, 약 7자리의 소수점 정밀도를 제공합니다.

- **double**: 64비트 실수로, 약 15자리의 소수점 정밀도를 제공합니다.

정밀도가 중요한 경우 double을 사용하는 것이 좋습니다. 

과학적 계산이나 금융 관련 개발에서는 double의 높은 정밀도가 필요하다.

### 문자형

- **char** 

하나의 문자를 저장하며 **8비트 메모리**를 사용하며 

문자 데이터를 **ASCII**코드로 변환해 저장합니다

- **string** 

여러 문자를 묶은 **문자열**을 저장하는 데 사용합니다. 

C++에서는 std::string 클래스를 통해 문자열을 다룰 수 있으며 

다양한 문자열 조작 함수 역시 제공합니다.

### 논리형 

논리형은 **참(true) 또는 거짓(false)을 저장**하는 자료형입니다. 

조건문이나 반복문에서 **조건을 검사**할 때 주로 사용됩니다.

- **true**는 1로 **false**는 0으로 표현됩니다.

- **1바이트 메모리**를 사용하며 조건에 따라 프로그램 흐름을 제어할 수 있습니다.

```
int a; // 유저가 입력할 변수
if (a > 10) {
    std::cout  << "a는 10보다 큽니다." << std::endl;
}
```

위 코드는 변수 `a`가 10보다 큰 경우 `"a는 10보다 큽니다."`를 출력합니다.

## 연산자

C++에서 연산자는 **프로그램 내에서 데이터를 처리하고 조작**하기 위해 

사용하는 **특수 기호**를 의미합니다. 

연산자는 **변숫값을 변경하거나 비교, 논리 연산을 수행**하는 데 사용됩니다.

C++의 연산자에는 **우선순위와 결합 규칙이 존재**하기에 

이를 이해하는 것이 **올바른 코드 작성**에 중요합니다.

### 산술 연산자

더하기(+), 빼기(-), 곱하기(*), 나누기(/), 나머지(%) 같은 

**기본 수학 연산**을 수행합니다.

- `a + b`는 **a와 b의 합**을 계산하고, `a % b`는 **a를 b로 나눈 나머지**를 반환합니다.

```
int x = 5;
int y = 3;
int result = x + y;  // result = 8
```

### 비교 연산자

비교 연산자는 두 값을 비교하여 

결과를 true 또는 false의 값으로 반환합니다.

- **==**: 같음

- **!=**: 다름

- **>**: 크다

- **=**: 크거나 같음

- ** 대입 연산자

변수에 값을 할당합니다

- **=**: 대입

- **+=, -=, *=, /=, %=**: 산술 연산 후 그 값을 다시 대입

```
int a = 3;
int b = a;  // b에 a의 값(3)을 대입

a += b;  // a = a + b (a는 6이 됨)
a -= b;  // a = a - b (a는 3이 됨)
a *= b;  // a = a * b (a는 9가 됨)
```
### 비트 연산자

비트 단위로 데이터를 조작합니다.

- **&**: 비트 AND

- **|**: 비트 OR

- **^**: 비트 XOR

- **~**: 비트 NOT

- ****: 오른쪽 시프트

## 제어문

C++ 프로그램에서는 **제어문은 사용해 코드의 실행흐름**을 제어합니다.

**실행 순서를 변경하거나 조건에 따라 다른 코드 블록을 실행**하고 

**반복적으로 특정 코드 블록을 실행** 할 수 있도록 해줍니다.

### if 문

`if` 문은 **특정 조건이 참일때만 코드 블록을 실행**합니다.

```
if (조건)
{
    // 조건이 참일 경우 실행할 코드 블록
}
```

- 15세 이상만 컨텐츠 이용 가능

```
int age = 16;

if (age >= 15)
{
    cout << "컨텐츠 이용이 가능합니다" << endl;
}
```

### else 문

`else` 문은 **if 문의 조건이 거짓일 때 코드 블록을 실행**한다.

```
if (조건)
{
    // 조건이 참일 경우 실행할 코드 블록
}
else
{
    // 조건이 거짓일 경우 실행할 코드 블록
}
```

- 나이에 따른 메시지 출력

```
int age = 13;

if (age >= 15)
{
    cout << "15세 이상입니다" << endl;
}
else
{
    cout << "이용이 불가능 합니다" << endl;
}
```

### else if 문

`else if` 문은 **여러 조건을 순차적으로 검사**할 때 유용하다. 조건에 따라 **첫 번째로 참인 코드 블록만 실행**된다.

```
if (조건1)
{
    // 조건1이 참일 경우 실행할 코드 블록
}
else if (조건2)
{
    // 조건2가 참일 경우 실행할 코드 블록
}
else
{
    // 모든 조건이 거짓일 경우 실행할 코드 블록
}
```

- 나이별 메시지 출력

```
int age = 10;

if (age >= 18)
{
    cout << "성인입니다" << endl;
}
else if (age >= 13)
{
    cout << "청소년입니다" << endl;
}
else
{
    cout << "어린이입니다" << endl;
}
```

### switch 문

`switch` 문은 **특정 변수의 값에 따라 여러 코드 블록 중 하나를 실행**합니다.

`case` 키워드를 사용해 **변수 값과 일치하는 블록**을 찾아 실행하며, 일치하지 않는 경우 `default` 블록을 실행합니다.

```
switch (변수)
{
    case 값1:
        // 값1과 일치할 경우 실행할 코드 블록
        break;
    case 값2:
        // 값2와 일치할 경우 실행할 코드 블록
        break;
    default:
        // 모든 case와 일치하지 않을 경우 실행할 코드 블록
}
```

- 계절 출력

```
int season = 2;

switch (season)
{
    case 1:
        cout << "봄" << endl;
        break;
    case 2:
        cout << "여름" << endl;
        break;
    case 3:
        cout << "가을" << endl;
        break;
    case 4:
        cout << "겨울" << endl;
        break;
    default:
        cout << "잘못된 계절입니다" << endl;
}
```
## 반복문

C++에서 반복문은 **특정 코드 블록을 여러번 실행**할때 사용하는 제어문이다. 

반복문을 사용하면 **코드를 간결하게 작성**하고 **반복 작업을 효율적으로 처리**할 수 있다.

### for 루프

`for` 루프는 **정해진 횟수만큼 반복**해야 할 때 사용한다. 

**초기문, 조건문, 증감문**이 한 곳에 모여 있어 반복 횟수를 명확하게 제어할 수 있다.

```
for (초기문; 조건문; 증감문)
{
    // 반복하고자 하는 내용
}
```

- 1부터 10까지 숫자 출력

```
for (int i = 1; i <= 10; i++)
{
    cout << i << endl;
}
```
### while 루프

`while` 루프는 **특정 조건이 참인 동안** 코드 블록을 반복 실행한다. 

조건이 참인 동안에만 반복하므로 **언제 반복이 종료될지 동적으로 결정**된다.

```
// 초기문
while (조건문)
{
    // 반복하고자 하는 내용
    // 증감문
}
```

- 1부터 10까지 숫자 출력

```
int i = 1;  // 초기문
while (i <= 10)  // 조건문
{
    cout << i << endl;  // 반복하고자 하는 내용
    i++;  // 증감문
}
```

### do-while 루프

`do-while` 루프는 **코드 블록을 최소 한 번 실행**한 후 조건을 검사합니다. 조건이 참이면 반복을 계속하며, 그렇지 않으면 종료됩니다. **최소 한 번은 반드시 실행**되어야 하는 작업에 적합합니다.

```
// 초기문
do
{
    // 반복하고자 하는 내용
}
while (조건문);
```

- 0을 입력할 때까지 숫자 입력받기

```
int num;  // 초기문
do
{
    cout << "숫자를 입력하세요(0을 입력하면 종료): ";
    cin >> num;
    cout << num << endl;
}
while (num != 0);
```
## 함수

C++에서 함수는 **특정 작업을 수행하는 코드 블록**를 의미한다. 

함수를 사용하면 **코드를 모듈화**하여 프로그램을 **더 잘 구성하고 관리**할 수 있으며, 

**코드의 재사용성**을 높일 수 있다.


```
반환형 함수이름(매개변수 목록)
{
    // 함수 본체
    return 반환값;
}

```
반환형: 함수가 **반환하는 값의 데이터 타입**을 나타냅니다. 반환형이 `void`인 경우 **반환 값이 없습니다**.

함수 이름: 함수를 **식별**하는 이름입니다.

매개변수 목록: 함수에 전달되는 **인자들의 타입과 이름**을 정의합니다.

함수 본체: 함수가 수행할 **코드 블록**입니다.

```
// 예제: 매개변수와 반환 값이 있는 함수
int Add(int a, int b)
{
    return a + b;
}
```

### 다양한 함수 형태

1. 매개변수와 반환 값이 있는 함수
    
    아래 함수는 **두 개의 매개변수를 받아** 그 합을 반환한다.
    
    ```
    int Add(int a, int b)
    {
        return a + b;
    }
    ```
    
2. 매개변수는 있지만 반환 값이 없는 함수
    
    아래 함수는 **매개변수로 전달된 값을 출력**하지만, 반환 값은 없습니다.
    
    ```
    void Print(int result)
    {
        cout << result << endl;
    }
    ```
    
3. **매개변수가 없지만 반환 값이 있는 함수**
    
    아래 함수는 **사용자로부터 값을 입력받아** 반환합니다.
    
    ```
    int Input()
    {
        int input;
        cin >> input;
        return input;
    }
    ```
    
4. **매개변수도 없고 반환 값도 없는 함수**
    
    아래 함수는 **단순한 메시지를 출력**하며, 매개변수와 반환 값이 없습니다.
    
    ```
    void PrintIntro()
    {
        cout << "C++ Study를 시작하겠습니다." << endl;
        cout << "모두 자리에 착석 해주십시오." << endl;
    }
    ```
    ## 포인터

C++에서 **포인터**는 **변수의 메모리 주소를 저장하는 특수한 변수**다.

컴퓨터는 데이터를 저장하기 위해 메모리를 사용하며, 각 메모리 공간은 고유한 주소를 가지고 있다.

포인터는 이러한 **메모리 주소를 저장해 해당 메모리 공간에 직접 접근할 수 있도록** 해준다.

이를 통해 **프로그램은 데이터를 효율적으로 관리하고 성능을 향상**시킬 수 있습니다.

포인터는 **변수의 값을 직접 읽거나 변경하는 데 사용**되며,

**함수에 데이터를 전달할 때 메모리를 효율적으로 관리**하는 데 유용하다.

**C++에서 포인터를 올바르게 이해하고 사용하는 것**은 매우 중요하다.

### 포인터 선언하기

포인터를 선언할 때는 변수 타입 앞에 별표(*)를 붙인다.

예를 들어, `int` 타입의 포인터를 선언하려면 `int *ptr`과 같이 작성한다.

포인터는 **해당 타입의 메모리 주소만 저장**할 수 있다.

```
int a = 100;
int* ptr = &a;

cout << a << endl;     // 100
cout << ptr << endl;    // a의 주소값 출력
cout << *ptr << endl;   // 100 (ptr이 가리키는 값)
```

### 포인터의 연산

포인터는 메모리 주소를 가리키므로, **주소를 이동하거나 값을 읽고 변경하는 연산**이 가능하다. 

`ptr + 1`은 단순히 1을 더하는 것이 아니라, **포인터가 가리키는 데이터 타입의 크기만큼 주소를 이동**한다. 

예를 들어, `int` 타입은 보통 4바이트이므로 `ptr + 1`은 현재 주소에서 4바이트 이동한다.

```
// 예: 포인터가 0x1000을 가리킬 때
| 0x1000 | 0x1001 | 0x1002 | 0x1003 | 0x1004 |
ptr + 1은 0x1004를 가리키게 됩니다.
```

### 포인터와 배열

배열의 이름은 **배열의 첫 번째 요소의 주소**를 나타내므로,

포인터 변수에 배열 이름을 할당하면 **배열의 첫 번째 요소를 가리키는 포인터**가 된다.

```
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // arr은 첫 번째 요소의 주소를 가리킴
```

위 코드에서 `arr`은 `arr[0]`의 주소를 가리키며, `ptr = arr`은 `ptr`이 `arr[0]`을 가리키도록 설정하는 것과 동일하다.

```
cout << *ptr << endl;        // 10 (arr[0])
cout << *(ptr + 1) << endl;  // 20 (arr[1])
cout << *(ptr + 2) << endl;  // 30 (arr[2])
```

### 포인터의 위험과 주의사항

**포인터의 잘못된 사용**은 프로그램에 심각한 오류를 유발할 수 있다.

- 널 포인터 참조

널 포인터는 **초기화되지 않거나 유효하지 않은 주소를 가리키는 포인터**입니다.

널 포인터를 참조하면 **런타임 오류(Segmentation Fault)**가 발생한다.

```
int* ptr = nullptr;
*ptr = 10;  // 잘못된 참조, 프로그램 비정상 종료
```

널 포인터를 사용할 때는 **반드시 널 여부를 확인**해야 한다.

```
if (ptr != nullptr) {
    *ptr = 10;
}
```

- Dangling Pointer 사용

Dangling Pointer는 **이미 해제된 메모리를 참조하는 포인터**이다. 

이런 포인터를 사용하면 **예기치 않은 동작**이 발생할 수 있다.

```
int* ptr = new int(10);
delete ptr;  // 메모리 해제
*ptr = 20;   // Dangling Pointer로 잘못된 접근
```

메모리를 해제한 후에는 **포인터를 반드시 널로 초기화**해야 한다.

```
ptr = nullptr;
```

- 초기화되지 않은 포인터 사용

초기화되지 않은 포인터는 **쓰레기 값(garbage value)**을 가리켜 예기치 않은 동작을 유발한다.

```
int* ptr;  // 초기화되지 않음
*ptr = 10;  // 잘못된 접근
```

포인터를 선언할 때는 **반드시 초기화**해야 한다.

- 배열 범위 초과

포인터를 이용해 배열에 접근할 때 배열의 **범위를 벗어나지 않도록 주의**해야 한다.

```
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
for (int i = 0; i <= 5; i++) {
    cout << *(ptr + i) << endl;  // i = 5는 잘못된 접근
}
```

코드에서 배열의 크기가 5인데, i가 5까지 증가하면서 **범위를 벗어난 메모리에 접근**하게 된다.

항상 **배열의 유효한 범위 내에서만 접근**해야 한다.
## 함수 포인터

C++에서 **함수 포인터**는 **함수의 메모리 주소를 저장하는 특수한 변수**이다.

이를 통해 **함수를 변수처럼 다룰 수 있으며**, **함수를 매개변수로 전달하거나 반환값으로 사용할 수 있다**.

함수 포인터를 사용하면 **특정 상황에 맞는 함수를 동적으로 선택**하여 호출하거나,

**함수를 데이터 구조에 저장**하여 필요할 때 호출할 수 있다.

### 함수 포인터 선언하기

함수 포인터는 **함수의 반환 타입과 매개변수 목록**을 기반으로 선언한다.

기본 구조는 다음과 같다.

```
리턴 타입 (*포인터 이름)(매개변수 타입들);
```

- 함수 포인터 선언

다음은 두 개의 정수를 더하는 `add` 함수를 정의하는 코드이다.

```
int add(int a, int b) {
    return a + b;
}
```

위 함수를 가리키는 함수 포인터는 아래와 같이 선언한다.

```
int (*funcPtr)(int, int);  // int를 반환하고 int 두 개를 매개변수로 받는 함수 포인터
```

### 함수 포인터에 함수 할당하기

이미 정의된 함수의 주소를 함수 포인터에 할당할 수 있다.

```
funcPtr = &add;  // 함수 주소를 포인터에 할당
funcPtr = add;   // & 생략 가능 (함수 이름은 함수의 주소를 가리킴)
```

### 함수 포인터를 사용해 함수 호출하기

함수 포인터를 사용해 할당된 함수를 호출할 수 있다.

```
int result = funcPtr(10, 20);  // add(10, 20)과 동일
std::cout << result << std::endl;  // 30 출력
```

### 함수 포인터를 매개변수로 전달하기

함수 포인터를 매개변수로 전달해 **동적으로 함수**를 호출할 수 있다.

```
void executeOperation(int a, int b, int (*operation)(int, int)) {
    std::cout << "Result: " << operation(a, b) << std::endl;
}
```

`add` 함수를 매개변수로 전달하여 실행한다.

```
int add(int a, int b) {
    return a + b;
}

executeOperation(10, 20, add);  // Result: 30 출력
```

## 클래스

C++에서 **클래스**는 **객체 지향 프로그래밍의 핵심 요소**로,

객체의 **데이터와 동작을 캡슐화**하여 **코드의 재사용성과 유지보수성**을 향상시킨다.

클래스를 사용하면 **다양한 객체를 모델링**하고,

**객체 지향 프로그래밍의 장점**을 효과적으로 활용할 수 있다.

### 클래스의 기본 구조

C++에서 클래스는 다음과 같은 구조로 정의된다.

```cpp
class 클래스이름 {
public:
    // 공개 멤버 변수 및 메소드
private:
    // 비공개 멤버 변수 및 메소드
};
```

- public: 외부에서 접근 가능한 멤버들
- private: 클래스 내부에서만 접근 가능한 멤버들

### 멤버 변수와 메소드

- **멤버 변수**는 클래스의 **인스턴스(객체)와 연관된 데이터**를 저장합니다.

```cpp
class Character {
public:
    std::string name;  // 이름
    int level;           // 레벨
};
```

- **메소드**는 클래스 내부의 **함수로, 객체의 동작을 정의**합니다.

```cpp

class Character {
public:
    std::string name;
    int level;

    // 멤버 변수에 값을 설정하는 메소드
    void setDetails(std::string n, int a) {
        name = n;
        level = a;
    }

    // 멤버 변수를 출력하는 메소드
    void printDetails() {
        std::cout << "Name: " << name << ", Level: " << level << std::endl;
    }
};
```

- 클래스 사용 예시

클래스를 정의한 후 **객체를 생성**하고 **멤버 변수와 메소드**에 접근할 수 있다.

```cpp
Character c;  // Character 객체 생성
c.setDetails("John", 25);
c.printDetails();  // 출력: Name: John, Level: 25
```

### 생성자와 소멸자

생성자(Constructor): 객체가 **생성될 때 자동으로 호출**되어 멤버 변수를 초기화한다.

소멸자(Destructor): 객체가 **소멸될 때 자동으로 호출**되며, 사용한 자원을 정리한다.

```cpp
class Character {
public:
    std::string name;
    int level;

    // 생성자: 객체 생성 시 호출
    Character(std::string n, int a) {
        name = n;
        level = a;
    }

    // 소멸자: 객체 소멸 시 호출
    ~Character() {
        std::cout << "Character object destroyed!" << std::endl;
    }

    void printDetails() {
        std::cout << "Name: " << name << ", Level: " << level << std::endl;
    }
};

Character c("Alice", 30);  // 생성자 호출
c.printDetails();  // 출력: Name: Alice, Level: 30
// 모든 코드가 실행 된 이후, 프로그램 종료 시 소멸자가 자동 호출 - "Character object destroyed!"
```

## 상속

C++에서 **상속**은 **기존 클래스의 기능을 이어받아 새로운 클래스를 만드는 중요한 개념**이다.

마치 부모로부터 자식이 유전적인 특징을 물려받는 것처럼, 상속을 통해 **기존 코드를 재사용**하여 **효율적인 개발**이 가능하다.

상속은 **코드 재사용성을 높이고 유지보수를 용이하게** 하여 프로그램을 **더 간결하고 관리하기 쉽게** 만든다.

### 상속의 기본 개념

- 부모 클래스(Base Class, Superclass): 다른 클래스에 의해 **상속되는 클래스**
- 자식 클래스(Derived Class, Subclass): 부모 클래스의 **멤버 변수와 메소드를 물려받는 클래스**

자식 클래스는 부모 클래스에서 **물려받은 멤버를 활용할 뿐만 아니라 새로운 멤버를 추가**하거나 **부모의 메소드를 재정의(오버라이딩)** 할 수 있다.

### 상속의 기본 구조

```cpp
class 부모클래스 {
    // 부모 클래스의 멤버 변수 및 메소드
};

class 자식클래스 : 접근지정자 부모클래스 {
    // 자식 클래스의 멤버 변수 및 메소드
};
```

**접근 지정자**는 부모 클래스의 멤버가 **자식 클래스에서 어떻게 상속될지**를 결정합니다.

- public 상속: 부모의 `public` 멤버는 자식의 `public`으로, `protected` 멤버는 자식의 `protected`로 상속됩니다.
- protected 상속: 부모의 `public`과 `protected` 멤버가 자식의 `protected`로 상속됩니다.
- private 상속: 부모의 모든 멤버가 자식의 `private`으로 상속됩니다.

---

- 상속 예제

```cpp
class Monster {
public:
    void speak() {
        std::cout << "몬스터들은 울음소리가 있습니다." << std::endl;
    }
};

class Orc : public Monster {
public:
    void growl() {
        std::cout << "취익" << std::endl;
    }
};

class cobolt : public Monster {
public:
    void growl() {
        std::cout << "캥캥" << std::endl;
    }
};

Orc myOrc;
myOrc.speak();  // 출력: 몬스터들은 울음소리가 있습니다.
myOrc.growl();   // 출력: 취익

cobolt myCobolt;
myCobolt.speak();  // 출력: 몬스터들은 울음소리가 있습니다.
myCobolt.growl();   // 출력: 캥캥
```

### 접근 제어

부모 클래스의 멤버가 자식 클래스에서 어떻게 보이는지는 **접근 제어 지정자**에 따라 다릅니다.

- **public 멤버**: 어디서든 접근 가능
- **protected 멤버**: 부모 클래스와 자식 클래스 내부에서만 접근 가능
- **private 멤버**: 부모 클래스 내부에서만 접근 가능, 자식 클래스에서는 접근 불가능

```cpp
class Monster {
public:
    void SetName(std::string n) {
        name = n;
    }

private:
    std::string name;
};

Orc myOrc;
myOrc.SetName("hark");  // 가능
myOrc.name = "hark";  // 오류: name은 private 멤버이기 때문에 직접 접근 불가능
```

### 메소드 오버라이딩

**오버라이딩(Overriding)**은 **자식 클래스가 부모 클래스의 메소드를 재정의**하는 것을 의미합니다.

이를 통해 **부모의 동작을 자식 클래스에 맞게 변경**할 수 있습니다.

```cpp
class Monster {
public:
    virtual void speak() {
        std::cout << "몬스터들은 울음소리가 있습니다." << std::endl;
    }
};

class Orc : public Monster {
public:
    void speak() override {
        std::cout << "취익" << std::endl;
    }
};

Monster* monsterPtr = new Orc();
monsterPtr->speak();  // 출력: 취익익 (오버라이딩된 함수 호출)
```

`virtual` 키워드를 사용해 부모 메소드를 가상 함수로 선언하면, **부모 타입의 포인터로 자식 클래스의 메소드를 호출**할 수 있습니다.

### 다중 상속

C++에서는 **하나의 자식 클래스가 여러 부모 클래스로부터 상속**받을 수 있습니다.

```cpp
class Monster {
public:
    void eat() {
        std::cout << "몬스터은 음식을 먹습니다." << std::endl;
    }
};

class Mammal {
public:
    void walk() {
        std::cout << "포유류형 몬스터는 걸을 수 있습니다." << std::endl;
    }
};

class Orc : public Monster, public Mammal {
public:
    void growl() {
        std::cout << "취익" << std::endl;
    }
};

Orc myOrc;
myOrc.eat();   // Monster 클래스의 메소드 호출
myOrc.walk();  // Mammal 클래스의 메소드 호출
myOrc.growl();  // Orc 클래스의 메소드 호출
```

## 템플릿

C++에서 템플릿(Template)은 함수나 클래스를 **일반화하여 다양한 데이터 타입을 처리**할 수 있도록 하는 기능입니다.

이를 통해 **중복된 코드를 줄이고 코드의 재사용성을 극대화**할 수 있게 됩니다.

**함수 템플릿**과 **클래스 템플릿**은 템플릿의 대표적인 두 가지 형태입니다.

### 템플릿의 기본 개념

템플릿은 코드 작성 시 **데이터 타입을 미리 지정하지 않고 매개변수로 받아** 나중에 지정한다.

이를 통해 다양한 타입에 대해 **동일한 작업을 수행할 수 있게 됩니다**.

```cpp
template <typename T>
```

- `T`는 **타입 매개변수**로 함수나 클래스에서 사용할 데이터 타입을 일반화한다.
- `typename` 대신 `class`를 사용해도 동일하게 동작한다.

### 함수 템플릿

**함수 템플릿**은 다양한 데이터 타입을 처리할 수 있는 **일반화된 함수**를 정의하는 방법이다.

예를 들어, 두 값을 비교하는 함수를 템플릿으로 작성하면 `int`, `double`, `char` 등 다양한 타입을 지원할 수 있다.

```cpp
template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

// int형 값을 비교
cout << "Max of 10 and 20: " << getMax(10, 20) << endl;  // 20

// double형 값을 비교
cout << "Max of 10.5 and 20.5: " << getMax(10.5, 20.5) << endl;  // 20.5

// char형 값을 비교
cout << "Max of 'a' and 'z': " << getMax('a', 'z') << endl;  // z
```

위에서 `getMax()`는 **템플릿 함수**로 작성되어 **다양한 데이터 타입에 대해 동일한 비교 작업**을 수행할 수 있게 된다.

이로써 코드의 중복을 줄이고 타입에 관계없이 유연하게 동작한다.

### 클래스 템플릿

**클래스 템플릿**은 다양한 데이터 타입을 처리할 수 있는 **일반화된 클래스를 정의**한다다.

이는 **스택, 리스트와 같은 자료구조**에서 주로 사용된다.

```cpp
template <typename T>
class Box {
private:
    T value;

public:
    // 생성자
    Box(T v) : value(v) {}

    // 값 출력 메소드
    void display() {
        cout << "Value: " << value << endl;
    }

    // 값 반환 메소드
    T getValue() {
        return value;
    }
};

// int형 값을 저장하는 Box 객체
Box<int> intBox(100);
intBox.display();  // 출력: Value: 100

// double형 값을 저장하는 Box 객체
Box<double> doubleBox(99.99);
doubleBox.display();  // 출력: Value: 99.99

// string형 값을 저장하는 Box 객체
Box<string> stringBox("Hello, Templates!");
stringBox.display();  // 출력: Value: Hello, Templates!
```

`Box` 클래스는 **템플릿으로 정의되어 다양한 데이터 타입에 대해 동작**할 수 있다.

예를 들어, `Box<int>`, `Box<double>`, `Box<string>`과 같이 **템플릿 클래스를 인스턴스화**할 때 데이터 타입을 지정한다.

이로써 **데이터 타입에 관계없이 동일한 로직**을 사용할 수 있게 된다.

### 템플릿의 장점

- 코드 재사용성: 동일한 코드가 여러 데이터 타입에서 동작하도록 일반화할 수 있다.
- 타입 안전성: 템플릿 사용 시 **타입 간 불일치 오류**는 컴파일 시점에서 발견된다.
- 유연성: 다양한 데이터 타입에 대해 **독립적인 코드**를 작성할 수 있다.

## 내일 학습 할 것은 무엇인지

내일은 오늘 배운 C++ 기본 요소들과 강의를 바탕으로 텍스트형 게임을 만드는 과제를 수행할 예정이다.

기본 요소를 활용하여 과제에서 원하는 기능을 구현하고, 게임의 재미를 위해 내가 생각하는 요소를 구상하여

과제에 구현해서 내가 플레이해도 재미있는 게임을 만들 예정이다.
